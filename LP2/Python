
1) A*

"""AI-2(A*).ipynb

Automatically generated by Colaboratory.
Original file is located at
    https://colab.research.google.com/drive/1x8A9bX9uWj-HTk3aIuvESdCFBghthT_u
"""

import heapq

def astar(start, goal, graph):
    # Initialize the open and closed lists
    open_list = [(0, start)]
    closed_list = set()

    # Initialize the path and cost dictionaries
    path = {start: None}
    cost = {start: 0}

    while open_list:
        # Get the node with the lowest cost from the open list
        current_cost, current_node = heapq.heappop(open_list)

        # Add the current node to the closed list
        closed_list.add(current_node)

        # Check if the goal node has been reached
        if current_node == goal:
            return reconstruct_path(path, start, goal)

        # Explore the neighbors of the current node
        for neighbor, weight in graph[current_node].items():
            # Calculate the tentative cost from the start node to the neighbor node
            tentative_cost = cost[current_node] + weight

            # Check if the neighbor node is already in the closed list
            if neighbor in closed_list:
                continue

            # Check if the neighbor node is not in the open list or has a lower cost
            if neighbor not in [node for _, node in open_list] or tentative_cost < cost[neighbor]:
                # Update the path and cost dictionaries
                path[neighbor] = current_node
                cost[neighbor] = tentative_cost

                # Calculate the heuristic value for the neighbor node
                heuristic_value = heuristic(neighbor, goal)

                # Add the neighbor node to the open list with the combined cost and heuristic value
                heapq.heappush(open_list, (tentative_cost + heuristic_value, neighbor))

    # No path found
    return None

def reconstruct_path(path, start, goal):
    # Reconstruct the shortest path from the goal node to the start node
    current_node = goal
    path_nodes = []

    while current_node != start:
        path_nodes.append(current_node)
        current_node = path[current_node]

    # Add the start node to the path
    path_nodes.append(start)

    # Reverse the path to get the correct order
    path_nodes.reverse()

    return path_nodes

def heuristic(node, goal):
    # Calculate the Manhattan distance as the heuristic
    return abs(ord(node) - ord(goal))

# Function to input the graph from the user
def get_graph_from_user():
    graph = {}

    num_edges = int(input("Enter the number of edges: "))

    for _ in range(num_edges):
        source = input("Enter the source node: ")
        target = input("Enter the target node: ")
        weight = int(input("Enter the weight: "))

        # Add the edge to the graph
        if source not in graph:
            graph[source] = {}
        graph[source][target] = weight

    return graph

# Example usage
graph = get_graph_from_user()

start_node = input("Enter the start node: ")
goal_node = input("Enter the goal node: ")
shortest_path = astar(start_node, goal_node, graph)

if shortest_path is None:
    print("No path found.")
else:
    print("Shortest path:", ' -> '.join(shortest_path))
    
-----------------------------------------------------------------------------------------------------

2) DFS BFS 

"""AI-1(bfs/dfs).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1OfhhaPENG-xkad-aCeZHcCSHUb_EaLBE
"""

from collections import defaultdict

class Graph:
    def __init__(self):
        self.graph = defaultdict(list)

    def add_edge(self, u, v):
        self.graph[u].append(v)
        self.graph[v].append(u)

    def dfs_util(self, v, visited):
        visited.add(v)
        print(v, end=" ")

        for neighbor in self.graph[v]:
            if neighbor not in visited:
                self.dfs_util(neighbor, visited)

    def dfs(self, start):
        visited = set()
        self.dfs_util(start, visited)

    def bfs(self, start):
        visited = set()
        queue = [start]
        visited.add(start)

        while queue:
            vertex = queue.pop(0)
            print(vertex, end=" ")

            for neighbor in self.graph[vertex]:
                if neighbor not in visited:
                    queue.append(neighbor)
                    visited.add(neighbor)

# Create a graph object
graph = Graph()

# Get the number of edges from the user
num_edges = int(input("Enter the number of edges: "))

# Get the edges from the user
for _ in range(num_edges):
    u, v = input("Enter an edge (u v): ").split()
    graph.add_edge(u, v)

# Get the starting vertex for traversal
start_vertex = input("Enter the starting vertex: ")

# Perform DFS and BFS
print("Depth First Search (DFS):")
graph.dfs(start_vertex)

print("\nBreadth First Search (BFS):")
graph.bfs(start_vertex)

-----------------------------------------------------------------------------------------------------

3) Kruskal

# -*- coding: utf-8 -*-
"""AI-6(Kruskal).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1yTZqCYk51TgG-LNXwEo8jFOC9fMCt2YM
"""

# Class to represent a graph
class Graph:
    def __init__(self, vertices):
        self.V = vertices
        self.graph = []

    # Function to add an edge to the graph
    def add_edge(self, src, dest, weight):
        self.graph.append([src, dest, weight])

    # Function to find the parent of a vertex
    def find_parent(self, parent, i):
        if parent[i] == i:
            return i
        return self.find_parent(parent, parent[i])

    # Function to perform union of two subsets
    def union(self, parent, rank, x, y):
        root_x = self.find_parent(parent, x)
        root_y = self.find_parent(parent, y)
        if rank[root_x] < rank[root_y]:
            parent[root_x] = root_y
        elif rank[root_x] > rank[root_y]:
            parent[root_y] = root_x
        else:
            parent[root_y] = root_x
            rank[root_x] += 1

    # Function to perform Kruskal's algorithm
    def kruskal_mst(self):
        result = []  # Stores the minimal spanning tree
        i = 0  # Index variable for sorted edges
        e = 0  # Index variable for result[]

        # Sort all the edges in non-decreasing order of their weight
        self.graph = sorted(self.graph, key=lambda item: item[2])

        parent = []
        rank = []

        # Create subsets with single elements
        for node in range(self.V):
            parent.append(node)
            rank.append(0)

        while e < self.V - 1:
            # Pick the smallest edge and increment the index for the next iteration
            src, dest, weight = self.graph[i]
            i += 1

            root_src = self.find_parent(parent, src)
            root_dest = self.find_parent(parent, dest)

            # Check if including the current edge causes a cycle or not
            if root_src != root_dest:
                e += 1
                result.append([src, dest, weight])
                self.union(parent, rank, root_src, root_dest)

        # Print the minimal spanning tree
        print("Minimal Spanning Tree:")
        for src, dest, weight in result:
            print(f"{src} -- {dest} \tWeight: {weight}")


# Take input from the user
vertices = int(input("Enter the number of vertices: "))
edges = int(input("Enter the number of edges: "))

# Create a graph object
graph = Graph(vertices)

# Input the edges and their weights
for i in range(edges):
    src, dest, weight = map(int, input("Enter source, destination, and weight of edge separated by spaces: ").split())
    graph.add_edge(src, dest, weight)

# Find and print the minimal spanning tree using Kruskal's algorithm
graph.kruskal_mst()

-----------------------------------------------------------------------------------------------------

4) Prims

"""A1-5(Prims).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1AX3PlsLwIiLah_qoaucgj7LlYYdmFgii
"""

# Function to find the vertex with the minimum key value
def min_key(vertices, keys, mst_set):
    min_key = float('inf')
    min_vertex = None
    for v in range(vertices):
        if keys[v] < min_key and not mst_set[v]:
            min_key = keys[v]
            min_vertex = v
    return min_vertex

# Function to print the minimal spanning tree
def print_mst(parent, graph):
    print("Edge   Weight")
    for i in range(1, len(parent)):
        print(parent[i], "-", i, "  ", graph[i][parent[i]])

# Prim's algorithm for minimal spanning tree
def prim_mst(graph):
    vertices = len(graph) # Number of vertices in the graph

    # Initialize key values and MST set
    keys = [float('inf')] * vertices
    parent = [None] * vertices
    mst_set = [False] * vertices

    # Starting vertex
    keys[0] = 0
    parent[0] = -1

    for _ in range(vertices - 1):
        # Choose the vertex with the minimum key value
        u = min_key(vertices, keys, mst_set)

        # Add the chosen vertex to the MST set
        mst_set[u] = True

        # Update the key values of adjacent vertices
        for v in range(vertices):
            if graph[u][v] > 0 and not mst_set[v] and graph[u][v] < keys[v]:
                keys[v] = graph[u][v]
                parent[v] = u

    # Print the minimal spanning tree
    print_mst(parent, graph)

# Take input from the user for the graph
vertices = int(input("Enter the number of vertices: "))
graph = []
for _ in range(vertices):
    row = list(map(int, input("Enter the weights for the vertices separated by spaces: ").split()))
    graph.append(row)

# Find the minimal spanning tree using Prim's algorithm
prim_mst(graph)

-----------------------------------------------------------------------------------------------------

5) Chatbot

def greet():
    print("Hi! Welcome to the flight booking application. How can I help you today?")

def book_flight():
    print("Sure, let's book a flight for you. Can you please tell me your departure and destination cities?")
    departure = input("Departure city: ")
    destination = input("Destination city: ")
    print("Great! Now, can you tell me your travel dates?")
    departure_date = input("Departure date (YYYY-MM-DD): ")
    return_date = input("Return date (YYYY-MM-DD): ")
    print("Thank you! Your flight has been booked from {0} to {1} departing on {2} and returning on {3}.".format(departure, destination, departure_date, return_date))

def check_flight_availability():
    print("Sure, let me check the availability of flights for you. Can you please tell me your departure and destination cities?")
    departure = input("Departure city: ")
    destination = input("Destination city: ")
    print("Great! Now, can you tell me your travel dates?")
    departure_date = input("Departure date (YYYY-MM-DD): ")
    print("Flights are available from {0} to {1} on {2}.".format(departure, destination, departure_date))

def get_flight_price():
    print("Sure, let me check the price of the flight for you. Can you please tell me your travel dates?")
    departure_date = input("Departure date (YYYY-MM-DD): ")
    return_date = input("Return date (YYYY-MM-DD): ")
    print("The price for your travel dates is $500.")

def book_hotel():
    print("Sure, let's book a hotel for you. Can you please tell me your destination city?")
    destination = input("Destination city: ")
    print("Great! Now, can you tell me your travel dates?")
    checkin_date = input("Check-in date (YYYY-MM-DD): ")
    checkout_date = input("Check-out date (YYYY-MM-DD): ")
    print("Thank you! Your hotel has been booked in {0} from {1} to {2}.".format(destination, checkin_date, checkout_date))

def cancel_booking():
    print("Sorry to hear that you want to cancel your booking. Please provide me with your booking reference number.")
    booking_ref = input("Booking reference number: ")
    try:
        booking_ref = int(booking_ref)
    except ValueError:
        print("Invalid booking reference number.")
        return
    print("Your booking with reference number {0} has been cancelled.".format(booking_ref))

def end():
    print("Thank you for using the flight booking application. Have a great day!")

greet()
while True:
    response = input("\nWhat would you like to do? (book a flight, check flight availability, get flight price, book hotel, cancel booking, exit): ")
    if "cancel" in response:
        cancel_booking()
    elif "hotel" in response:
        book_hotel()
    elif "book" in response:
        book_flight()
    elif "check" in response:
        check_flight_availability()
    elif "price" in response:
        get_flight_price()
    elif "exit" in response:
        end()
        break
    else:
        print("I'm sorry, I didn't understand that. Please try again.")
          
-----------------------------------------------------------------------------------------------------

6) Dijkstra -

"""AI-4(dijikstra's).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1alMkG2llI3rTupLB2sEqioTxgKgY-UCk
"""

import sys

def dijkstra(graph, start, end):
    # Initialize the distances with infinity for all nodes except the start node
    distances = {node: float('inf') for node in graph}
    distances[start] = 0

    # Keep track of visited nodes and previous nodes in the shortest path
    visited = set()
    previous = {}

    while len(visited) < len(graph):
        # Find the node with the minimum distance
        min_distance = float('inf')
        min_node = None

        for node in graph:
            if node not in visited and distances[node] < min_distance:
                min_distance = distances[node]
                min_node = node

        # Mark the current node as visited
        visited.add(min_node)

        # Stop the algorithm if the destination node is reached
        if min_node == end:
            break

        # Update the distances of the neighboring nodes
        for neighbor, weight in graph[min_node].items():
            new_distance = distances[min_node] + weight
            if new_distance < distances[neighbor]:
                distances[neighbor] = new_distance
                previous[neighbor] = min_node

    # If there is no path to the destination node, return None
    if end not in previous:
        return None

    # Reconstruct the shortest path from start to end
    path = [end]
    node = end
    while node != start:
        node = previous[node]
        path.append(node)

    # Reverse the path to get the correct order
    path.reverse()

    return path, distances[end]

# Take graph input from the user
graph = {}
num_vertices = int(input("Enter the number of vertices in the graph: "))

for i in range(num_vertices):
    vertex = input("Enter the vertex: ")
    edges = input("Enter the connected vertices and their weights (comma-separated): ")
    edges = edges.split(',')

    graph[vertex] = {}
    for j in range(0, len(edges), 2):
        neighbor = edges[j]
        weight = int(edges[j+1])
        graph[vertex][neighbor] = weight

start_node = input("Enter the start node: ")
end_node = input("Enter the end node: ")

# Run Dijkstra's algorithm
shortest_path = dijkstra(graph, start_node, end_node)

if shortest_path is None:
    print("No path found.")
else:
    path, distance = shortest_path
    print("Shortest path:", ' -> '.join(path))
    print("Shortest distance:", distance)
    
-----------------------------------------------------------------------------------------------------

7) Graph Coloring 

# -*- coding: utf-8 -*-
"""AI-7(graph_colouring).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1n828ynFGsBgbjUv2dqa_oobmLLK47xDS
"""

def graph_coloring(graph, num_colors):
    # Create a list to store the color assigned to each vertex
    colors = [0] * len(graph)

    def is_safe(vertex, color):
        # Check if it is safe to color the vertex with the given color
        for neighbor in graph[vertex]:
            if colors[neighbor] == color:
                return False
        return True

    def backtrack(vertex):
        # Base case: All vertices have been assigned colors
        if vertex == len(graph):
            return True

        # Try all possible colors for the current vertex
        for color in range(1, num_colors + 1):
            if is_safe(vertex, color):
                # Assign the color to the vertex
                colors[vertex] = color

                # Recursively backtrack to assign colors to the remaining vertices
                if backtrack(vertex + 1):
                    return True

                # If the current configuration doesn't lead to a solution, backtrack
                colors[vertex] = 0

        return False

    # Start with the first vertex (vertex index 0)
    if backtrack(0):
        # If a solution is found, print the color assignment
        print("Color assignment:")
        for vertex, color in enumerate(colors):
            print(f"Vertex {vertex}: Color {color}")
    else:
        print("No solution found.")

# Gather the graph information from the user
num_vertices = int(input("Enter the number of vertices: "))

graph = {}
for vertex in range(num_vertices):
    neighbors = input(f"Enter the neighbors of vertex {vertex} (separated by spaces): ").split()
    graph[vertex] = [int(neighbor) for neighbor in neighbors]

# Prompt the user to enter the number of colors
num_colors = int(input("Enter the number of colors: "))

# Call the graph_coloring function
graph_coloring(graph, num_colors)

-----------------------------------------------------------------------------------------------------

8) N-Queens 

# -*- coding: utf-8 -*-
"""AI-8(n-queens).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19Dso-X1eO_ZAJjQ5oHWrPQiRD5MZ1jl9
"""

def solve_n_queens(n):
    board = [[0] * n for _ in range(n)]  # Create an empty chessboard
    queens = []  # List to store the column position of queens

    def is_safe(row, col):
        # Check if placing a queen at the given position is safe
        # Check column
        for i in range(row):
            if board[i][col] == 1:
                return False
        # Check upper diagonal
        i, j = row, col
        while i >= 0 and j >= 0:
            if board[i][j] == 1:
                return False
            i -= 1
            j -= 1
        # Check lower diagonal
        i, j = row, col
        while i >= 0 and j < n:
            if board[i][j] == 1:
                return False
            i -= 1
            j += 1
        return True

    def backtrack(row):
        if row == n:
            # All queens have been placed, print the solution
            print_solution()
            return True
        for col in range(n):
            if is_safe(row, col):
                # Place a queen at the current position
                board[row][col] = 1
                queens.append(col)

                # Recursively backtrack to place the remaining queens
                if backtrack(row + 1):
                    return True

                # If the current configuration doesn't lead to a solution, backtrack
                board[row][col] = 0
                queens.pop()

        return False

    def print_solution():
        # Print the board configuration
        for row in range(n):
            for col in range(n):
                if queens[row] == col:
                    print("Q", end=" ")
                else:
                    print(".", end=" ")
            print()

    # Start with the first row (row index 0)
    backtrack(0)

# Prompt the user to enter the number of queens
n = int(input("Enter the number of queens: "))
solve_n_queens(n)

-----------------------------------------------------------------------------------------------------

9) Selection Sort

# -*- coding: utf-8 -*-
"""AI-3(selection-sort).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Re5d4kLkEb38VyciVXEvjdP_z98Ajyqb
"""

def selection_sort(arr):
    n = len(arr)

    for i in range(n - 1):
        min_index = i

        # Find the minimum element in the remaining unsorted portion of the array
        for j in range(i + 1, n):
            if arr[j] < arr[min_index]:
                min_index = j

        # Swap the minimum element with the first element of the unsorted portion
        arr[i], arr[min_index] = arr[min_index], arr[i]

    return arr

# Take input array from the user
input_str = input("Enter the elements of the array (space-separated): ")
array = [int(x) for x in input_str.split()]

# Perform selection sort
sorted_array = selection_sort(array)

# Print the sorted array
print("Sorted array:", sorted_array)
